!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! nd2hiphive. Copyright (C) Antonio Cammarata
! https://nano.cvut.cz/researchers/antonio-cammarata
! https://orcid.org/0000-0002-5691-0682
! 
! Processes an ND trajectory and Creates input files for hiPhive 
! (https://hiphive.materialsmodeling.org/)
! to calculate the effective interatomic force constants
! 
! If used for production, you should cite
! Phys. Rev. B XX, XXXXX (XXXX)
! https://doi.org/10.1103/xxx
!
!    This file is part of nd2hiphive.
!
! This program is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 2 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along
! with this program; if not, write to the Free Software Foundation, Inc.,
! 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! v. 0.8
! - corrected a bug in writing ndhiPhive_phonopy.py when the number of atoms in
!   the reference cell is equal to 1
!
! v. 0.7
! - routine variables changed according to the normal_to_cartesian routine
!   taken from pindol v. 1.13
!
! v. 0.6
! - the eigenvectors and frequencies are read from files qmatrix.nd and freq.nd
!   generated by qpoints v >= 1.3
!
! v. 0.5
! - the freq and qmatrix files are read in the format of qpoints v=1.2
!
! v. 0.4
! improved the skip of lines in trajectory and Qddot file
!
! v. 0.3
! the volume factor in POSCAR is taken into account
!
! v. 0.2
! ndhiPhive_posfor.xyz is not written any more; instead ndhiPhive_dispfor.xyz is written,
!    containing displacements and forces
!
! v. 0.1
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Format of the input file
!
! char                  name of the POSCAR file
! char                  name of the ND trajectory file
! char                  name of the ND Qddot file
! int                   number of atomic types (natom_types)
! char double           atomic symbol and mass (at_pertype(i), mass_pertype(i) [uma] of atom type 1
! ...  ...
! char double           atomic symbol and mass (at_pertype(i), mass_pertype(i) [uma] of atom type natom_types
! double double double        initial time, final time, max skip time
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module var
  ! global parameters
  character(10), parameter :: progname = 'ND2HIPHIVE'
  real(8), parameter :: uma_to_kg = 1.66053906660d-27     ! taken from NIST, 1 uma = 1.66053906660 x 10-27 kg
  real(8), parameter :: eV_to_J = 1.602176634d-19         ! taken from NIST, 1 e = 1.602176634 x 10-19 C 
  real(8), parameter :: eV_to_ieu = 1.d-10 * eV_to_J / uma_to_kg
  real(8), parameter :: internal_to_eVAng = 1.d0/eV_to_ieu ! internal energy units to eV/Ang
  character(3), parameter :: version='0.8'
  character(8), parameter :: error_string = ' ERROR: '
  ! from input
  integer, save :: nq_chk, natom_types
  real(8), save :: t1, t2, skip
  real(8), save, allocatable :: mass_pertype(:)
  character(2), save, allocatable :: at_pertype(:)
  character(256), save :: infile_q, infile_qdd
  ! from equilibrium UC
  integer, save :: atoms_UC, ncells(3), atoms_EC, ncells_tot
  integer, save, allocatable :: natoms_UC(:)
  real(8), save :: side_eq_UC(3,3), side_eq_EC(3,3)
  real(8), save, allocatable :: pos_eq_UC(:,:), mass_UC(:)
  real(8), save, allocatable :: pos_eq_EC(:,:,:) 
  character(2), save, allocatable :: at_UC(:), at_EC(:,:)
  ! from qmatrix_*, freq_* 
  integer, save :: npG, npH, npS, npunique, nptot
  integer, save :: nq, npGq, npHq, npSq, npuniqueq, nptotq, npdiffq
  real(8), save, allocatable :: vec(:,:), vec_red(:,:)
  complex(8), save, allocatable :: eigen(:,:)
  ! delta
  real(8), parameter :: toldelta = 1.d-4

end module var

module functions
contains
  
  function i2a(i) result(out)
    character(:), allocatable :: out
    integer, intent(in) :: i
    character(range(i)+2) :: x

    write(x,'(i0)') i

    out = trim(x)
    
  end function i2a

  function f2a(f) result(out)
    character(20) :: out
    real(8), intent(in) :: f
    character(20) :: x

    write(x,'(E13.5)') f

    out = trim(x)
  end function f2a

  ! https://fortranwiki.org/fortran/show/Matrix+inversion
  ! Returns the inverse of a matrix calculated by finding the LU
  ! decomposition.  Depends on LAPACK.
  function inv(A) result(Ainv)
    real(8), dimension(:,:), intent(in) :: A
    real(8), dimension(size(A,1),size(A,2)) :: Ainv
  
    real(8), dimension(size(A,1)) :: work  ! work array for LAPACK
    integer, dimension(size(A,1)) :: ipiv   ! pivot indices
    integer :: n, info
  
    ! External procedures defined in LAPACK
    external DGETRF
    external DGETRI
  
    ! Store A in Ainv to prevent it from being overwritten by LAPACK
    Ainv = A
    n = size(A,1)
  
    ! DGETRF computes an LU factorization of a general M-by-N matrix A
    ! using partial pivoting with row interchanges.
    call DGETRF(n, n, Ainv, n, ipiv, info)
  
    if (info /= 0) then
       stop 'Matrix is numerically singular!'
    end if
  
    ! DGETRI computes the inverse of a matrix using the LU factorization
    ! computed by DGETRF.
    call DGETRI(n, Ainv, n, ipiv, work, n, info)
  
    if (info /= 0) then
       stop 'Matrix inversion failed!'
    end if
  end function inv

end module functions

program nd2hiphive

  call init

  call read_eigen

  call write_xhiphive

  call deallocate_all
  call credits
  
  write(*,'(a)') ' Execution terminated.'
  write(*,*)

  stop
end program nd2hiphive
